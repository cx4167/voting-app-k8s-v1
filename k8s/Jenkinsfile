pipeline {
    agent any
    
    environment {
        // Docker Hub details
        DOCKER_REGISTRY = 'denish952'
        DOCKER_IMAGE_VOTE = "${DOCKER_REGISTRY}/voting-app-vote"
        DOCKER_IMAGE_WORKER = "${DOCKER_REGISTRY}/voting-app-worker"
        DOCKER_IMAGE_RESULT = "${DOCKER_REGISTRY}/voting-app-result"
        
        // Build identifier
        BUILD_TAG = "${BUILD_NUMBER}"
        
        // Kubernetes namespaces
        DEV_NAMESPACE = 'voting-app-dev'
        PROD_NAMESPACE = 'voting-app'
        
        // Kubeconfig
        KUBECONFIG = '/var/jenkins_home/.kube/config'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 1, unit: 'HOURS')
    }
    
    stages {
        stage('ğŸ“¥ Checkout Code') {
            steps {
                echo '==================== Pulling Code from GitHub ===================='
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    userRemoteConfigs: [[
                        url: 'https://github.com/cx4167/voting-app-k8s.git',
                        credentialsId: 'github-credentials'
                    ]]
                ])
                sh 'git log -1 --oneline'
            }
        }
        
        stage('ğŸ”¨ Build Docker Images') {
            parallel {
                stage('ğŸ—³ï¸  Build Vote') {
                    steps {
                        echo '========== Building Vote Service =========='
                        script {
                            sh '''
                                echo "Building: ${DOCKER_IMAGE_VOTE}:${BUILD_TAG}"
                                docker build -t ${DOCKER_IMAGE_VOTE}:${BUILD_TAG} \
                                    -t ${DOCKER_IMAGE_VOTE}:latest \
                                    -f docker/vote/Dockerfile docker/vote/
                                docker images | grep voting-app-vote | head -2
                            '''
                        }
                    }
                }
                
                stage('âš™ï¸  Build Worker') {
                    steps {
                        echo '========== Building Worker Service =========='
                        script {
                            sh '''
                                echo "Building: ${DOCKER_IMAGE_WORKER}:${BUILD_TAG}"
                                docker build -t ${DOCKER_IMAGE_WORKER}:${BUILD_TAG} \
                                    -t ${DOCKER_IMAGE_WORKER}:latest \
                                    -f docker/worker/Dockerfile docker/worker/
                                docker images | grep voting-app-worker | head -2
                            '''
                        }
                    }
                }
                
                stage('ğŸ“Š Build Result') {
                    steps {
                        echo '========== Building Result Service =========='
                        script {
                            sh '''
                                echo "Building: ${DOCKER_IMAGE_RESULT}:${BUILD_TAG}"
                                docker build -t ${DOCKER_IMAGE_RESULT}:${BUILD_TAG} \
                                    -t ${DOCKER_IMAGE_RESULT}:latest \
                                    -f docker/result/Dockerfile docker/result/
                                docker images | grep voting-app-result | head -2
                            '''
                        }
                    }
                }
            }
        }
        
        stage('âœ… Run Tests') {
            steps {
                echo '========== Running Unit Tests =========='
                script {
                    sh '''
                        echo "Testing Vote Service..."
                        docker run --rm ${DOCKER_IMAGE_VOTE}:${BUILD_TAG} \
                            python -c "from flask import Flask; print('âœ… Vote app OK')" || true
                        
                        echo "Testing Worker Service..."
                        docker run --rm ${DOCKER_IMAGE_WORKER}:${BUILD_TAG} \
                            python -c "import redis, psycopg2; print('âœ… Worker dependencies OK')" || true
                        
                        echo "Testing Result Service..."
                        docker run --rm ${DOCKER_IMAGE_RESULT}:${BUILD_TAG} \
                            python -c "from flask import Flask; print('âœ… Result app OK')" || true
                    '''
                }
            }
        }
        
        stage('ğŸ“¤ Push to Docker Hub') {
            steps {
                echo '========== Pushing Images to Docker Hub =========='
                script {
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', 
                                     usernameVariable: 'DOCKER_USER', 
                                     passwordVariable: 'DOCKER_PASS')]) {
                        sh '''
                            echo "${DOCKER_PASS}" | docker login -u "${DOCKER_USER}" --password-stdin
                            
                            echo "Pushing Vote:${BUILD_TAG}..."
                            docker push ${DOCKER_IMAGE_VOTE}:${BUILD_TAG}
                            docker push ${DOCKER_IMAGE_VOTE}:latest
                            
                            echo "Pushing Worker:${BUILD_TAG}..."
                            docker push ${DOCKER_IMAGE_WORKER}:${BUILD_TAG}
                            docker push ${DOCKER_IMAGE_WORKER}:latest
                            
                            echo "Pushing Result:${BUILD_TAG}..."
                            docker push ${DOCKER_IMAGE_RESULT}:${BUILD_TAG}
                            docker push ${DOCKER_IMAGE_RESULT}:latest
                            
                            docker logout
                            
                            echo "âœ… All images pushed successfully!"
                        '''
                    }
                }
            }
        }
        
        stage('ğŸ”„ Update K8s Manifests') {
            steps {
                echo '========== Updating Kubernetes Manifests =========='
                script {
                    sh '''
                        echo "Updating image tags to: ${BUILD_TAG}"
                        
                        # Update Vote manifest
                        sed -i "s|image: denish952/voting-app-vote:.*|image: denish952/voting-app-vote:${BUILD_TAG}|g" \
                            k8s/vote/vote-deployment.yaml
                        
                        # Update Worker manifest
                        sed -i "s|image: denish952/voting-app-worker:.*|image: denish952/voting-app-worker:${BUILD_TAG}|g" \
                            k8s/worker/worker-deployment.yaml
                        
                        # Update Result manifest
                        sed -i "s|image: denish952/voting-app-result:.*|image: denish952/voting-app-result:${BUILD_TAG}|g" \
                            k8s/result/result-deployment.yaml
                        
                        echo "Updated manifests:"
                        echo "Vote:"
                        grep "image:" k8s/vote/vote-deployment.yaml | head -1
                        echo "Worker:"
                        grep "image:" k8s/worker/worker-deployment.yaml | head -1
                        echo "Result:"
                        grep "image:" k8s/result/result-deployment.yaml | head -1
                    '''
                }
            }
        }
        
        stage('ğŸš€ Deploy to DEV') {
            steps {
                echo '========== Deploying to DEV Kubernetes =========='
                script {
                    sh '''
                        # Create namespace
                        kubectl create namespace ${DEV_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        
                        echo "Deploying to ${DEV_NAMESPACE}..."
                        
                        # Deploy configurations
                        kubectl apply -f k8s/configmap.yaml -n ${DEV_NAMESPACE}
                        kubectl apply -f k8s/secrets.yaml -n ${DEV_NAMESPACE}
                        kubectl apply -f k8s/pv-pvc.yaml -n ${DEV_NAMESPACE}
                        
                        # Deploy services
                        kubectl apply -f k8s/postgres/postgres-deployment.yaml -n ${DEV_NAMESPACE}
                        kubectl apply -f k8s/redis/redis-deployment.yaml -n ${DEV_NAMESPACE}
                        kubectl apply -f k8s/worker/worker-deployment.yaml -n ${DEV_NAMESPACE}
                        kubectl apply -f k8s/vote/vote-deployment.yaml -n ${DEV_NAMESPACE}
                        kubectl apply -f k8s/result/result-deployment.yaml -n ${DEV_NAMESPACE}
                        
                        echo "Waiting for deployments to be ready..."
                        kubectl rollout status deployment/vote -n ${DEV_NAMESPACE} --timeout=5m || true
                        kubectl rollout status deployment/worker -n ${DEV_NAMESPACE} --timeout=5m || true
                        kubectl rollout status deployment/result -n ${DEV_NAMESPACE} --timeout=5m || true
                        
                        echo ""
                        echo "DEV Cluster Status:"
                        kubectl get all -n ${DEV_NAMESPACE}
                        
                        echo ""
                        echo "Services and NodePorts:"
                        kubectl get svc -n ${DEV_NAMESPACE}
                    '''
                }
            }
        }
        
        stage('â¸ï¸  Approval for PROD') {
            when {
                branch 'main'
            }
            steps {
                script {
                    timeout(time: 24, unit: 'HOURS') {
                        def userInput = input(
                            id: 'Prod-Deploy-Approval',
                            message: '''
                            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                            â•‘  ğŸš€ READY TO DEPLOY TO PRODUCTION? ğŸš€  â•‘
                            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            Build: ${BUILD_NUMBER}
                            Images Tagged: ${BUILD_TAG}
                            
                            Current Status:
                            âœ… Code tested
                            âœ… Images built and pushed
                            âœ… Deployed to DEV successfully
                            
                            Click "Proceed" to deploy to Production
                            ''',
                            parameters: [
                                string(
                                    name: 'APPROVAL_REASON',
                                    description: 'Why deploy to production?',
                                    defaultValue: 'Scheduled production update'
                                )
                            ]
                        )
                        env.APPROVAL_REASON = userInput
                        env.APPROVED = 'true'
                    }
                }
            }
        }
        
        stage('âœˆï¸  Deploy to PROD') {
            when {
                branch 'main'
                environment name: 'APPROVED', value: 'true'
            }
            steps {
                echo '========== Deploying to PRODUCTION Kubernetes =========='
                script {
                    sh '''
                        # Create namespace
                        kubectl create namespace ${PROD_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        
                        echo "ğŸš€ Deploying to ${PROD_NAMESPACE}..."
                        
                        # Deploy configurations (first time only)
                        kubectl apply -f k8s/configmap.yaml -n ${PROD_NAMESPACE} || true
                        kubectl apply -f k8s/secrets.yaml -n ${PROD_NAMESPACE} || true
                        kubectl apply -f k8s/pv-pvc.yaml -n ${PROD_NAMESPACE} || true
                        
                        # Deploy database (first time only)
                        kubectl apply -f k8s/postgres/postgres-deployment.yaml -n ${PROD_NAMESPACE} || true
                        kubectl apply -f k8s/redis/redis-deployment.yaml -n ${PROD_NAMESPACE} || true
                        
                        # Update application services (rolling update)
                        kubectl apply -f k8s/worker/worker-deployment.yaml -n ${PROD_NAMESPACE}
                        kubectl apply -f k8s/vote/vote-deployment.yaml -n ${PROD_NAMESPACE}
                        kubectl apply -f k8s/result/result-deployment.yaml -n ${PROD_NAMESPACE}
                        
                        echo ""
                        echo "Waiting for PRODUCTION deployment to be ready..."
                        kubectl rollout status deployment/vote -n ${PROD_NAMESPACE} --timeout=5m
                        kubectl rollout status deployment/worker -n ${PROD_NAMESPACE} --timeout=5m
                        kubectl rollout status deployment/result -n ${PROD_NAMESPACE} --timeout=5m
                        
                        echo ""
                        echo "âœ… PRODUCTION Deployment Complete!"
                        echo ""
                        echo "Production Services:"
                        kubectl get svc -n ${PROD_NAMESPACE}
                        
                        echo ""
                        echo "Production Pods:"
                        kubectl get pods -n ${PROD_NAMESPACE}
                    '''
                }
            }
        }
    }
    
    post {
        always {
            script {
                sh 'docker image prune -af --filter "until=168h" || true'
            }
        }
        
        success {
            echo '''
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            â•‘     âœ… PIPELINE SUCCESSFUL! âœ…          â•‘
            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            '''
        }
        
        failure {
            echo '''
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            â•‘     âŒ PIPELINE FAILED! âŒ              â•‘
            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Check logs above for details
            '''
        }
    }
}
